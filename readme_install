sudo apt-get update
sudo apt-get install -y ca-certificates curl gnupg
sudo mkdir -p /etc/apt/keyrings
curl -fsSL https://deb.nodesource.com/gpgkey/nodesource-repo.gpg.key | sudo gpg --dearmor -o /etc/apt/keyrings/nodesource.gpg
NODE_MAJOR=20
echo "deb [signed-by=/etc/apt/keyrings/nodesource.gpg] https://deb.nodesource.com/node_$NODE_MAJOR.x nodistro main" | sudo tee /etc/apt/sources.list.d/nodesource.list
sudo apt-get update
sudo apt-get install nodejs -y
npm install web3
npm install --save-dev @nomiclabs/hardhat-ethers ethers @nomiclabs/hardhat-waffle ethereum-waffle chai
   

mkdir gaming
cd gaming
npx hardhat init
cd contract


vi Gaming.sol



pragma solidity ^0.8.0;

contract Gaming {
    /* Our Online gaming contract */
    address payable public  owner;
    bool online;

    uint public wins;    /* public didnt allow me any advantage */
    uint public losses;
    // unit public mysteryniumber


    struct Player {
        uint wins;
        uint losses;
    }

    mapping (address => Player) public players;
    
    function getWins() external payable returns ( uint ) { 
	return wins;
    }
    
    function getLosses() external payable returns ( uint ) { 
	return losses;
    }

    constructor() public payable {
        owner = payable(msg.sender);
        online = true;
	wins = 0;
	losses = 0;
    }

    modifier isOwner() {
        require(msg.sender == owner, "Only owner can call this function");
        _;
    }

    event PlayerWon(address player, uint amount, uint mysteryNumber, uint displayedNumber);
    event PlayerLost(address player, uint amount, uint mysteryNumber, uint displayedNumber);

    event GameFunded(address funder, uint amount);

    function mysteryNumber() private view returns (uint) {
        //uint randomNumber = uint(blockhash(block.number-1))%10 + 1;
        uint randomNumber = 5;
	return randomNumber;
    }

// true == my number ( display is > myster number )
// myNumber is also known as the 'display' number
    function determineWinner(uint mysteryNumber, uint myNumber, bool guess) public pure returns (bool) {
        if (guess == true) {
            if (myNumber > mysteryNumber){
                return true;
            }
            if (myNumber < mysteryNumber) {
                return false;
            }
        } else if (guess == false) {
            if (mysteryNumber > myNumber) {
                return true;
            }
            if (mysteryNumber < myNumber) {
                return false;
            }
        }
    }

    event RoundComplete(uint wager, uint playerNumber, uint mysteryNumber, bool guess, string result);
   
   function winOrLose(uint display, bool guess) external payable returns (bool, uint) {
        /* Use true for a higher guess, false for a lower guess */
        require(online == true, "The game is not online");
        require(msg.sender.balance > msg.value, "Insufficient funds");
        uint mysteryNumber_ = mysteryNumber();
        bool isWinner = determineWinner(mysteryNumber_, display, guess);
        Player storage player = players[msg.sender];
        if (isWinner == true) {
            /* Player won */
            player.wins += 1;
	    wins += 1;
            payable(msg.sender).transfer(msg.value * 2);
            emit RoundComplete(msg.value, display, mysteryNumber_, guess, "won");
            return (true, mysteryNumber_);
        } else if (isWinner == false) {
            /* Player lost */
            player.losses += 1;
	    losses += 1;
            emit RoundComplete(msg.value, display, mysteryNumber_, guess, "lost");
            return (false, mysteryNumber_);
        }
    }

    function withdrawFunds() public isOwner {
        payable(msg.sender).transfer(address(this).balance);
    }

    function fundGame() public isOwner payable {
        emit GameFunded(msg.sender, msg.value);
    }


}


npx hardhat node --hostname localhost    # make sure to run as localhost vs the dns


npx hardhat console --network localhost


ubuntu@ip-172-31-27-33:~/gaming$
npx hardhat console --network localhost
Welcome to Node.js v18.19.1.
Type ".help" for more information.
> const signers = await ethers.getSigners();
undefined
>  const contract =  await ethers.getContractFactory("Gaming")
undefined
> const cd = await contract.deploy()
undefined
> const [deployer] = await ethers.getSigners();
undefined
>  await ethers.provider.getBalance(cd.target)
0n
> cd.target
'0x5FbDB2315678afecb367f032d93F642f64180aa3'
> cd
BaseContract {
  target: '0x5FbDB2315678afecb367f032d93F642f64180aa3',
  interface: Interface {
    fragments: [
      [ConstructorFragment],
      [EventFragment],
      [EventFragment],
      [EventFragment],
      [EventFragment],
      [FunctionFragment],
      [FunctionFragment],
      [FunctionFragment],
      [FunctionFragment],
      [FunctionFragment],
      [FunctionFragment],
      [FunctionFragment],
      [FunctionFragment],
      [FunctionFragment],
      [FunctionFragment]
    ],
    deploy: ConstructorFragment {
      type: 'constructor',
      inputs: [],
      payable: false,
      gas: null
    },
    fallback: null,
    receive: false
  },
  runner: HardhatEthersSigner {
    _gasLimit: 30000000,
    address: '0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266',
    provider: HardhatEthersProvider {
      _hardhatProvider: [LazyInitializationProviderAdapter],
      _networkName: 'localhost',
      _blockListeners: [],
      _transactionHashListeners: Map(0) {},
      _eventListeners: []
    }
  },
  filters: {},
  fallback: null,
  [Symbol(_ethersInternal_contract)]: {}
}
>  await ethers.provider.getBalance(signers[0])
9999999089287257812500n
> cd.fundGame({value: ethers.parseEther("100.0")})
Promise {
  <pending>,
  [Symbol(async_id_symbol)]: 4689,
  [Symbol(trigger_async_id_symbol)]: 14
}
>  await ethers.provider.getBalance(cd.target)
100000000000000000000n
>  await ethers.provider.getBalance(signers[0])
9899999064880485129812n
> const bal1 =  await ethers.provider.getBalance(signers[0])
undefined
> bal1
9899999064880485129812n
> const contractbal1 =  await ethers.provider.getBalance(cd.target)
undefined
> contractbal1
100000000000000000000n
> await cd2.winOrLose(10, true, {from: signers[0] ,value: ethers.parseEther("21.0") }
... )
Uncaught ReferenceError: cd2 is not defined
    at REPL46:1:39
> await cd.winOrLose(10, true, {from: signers[0] ,value: ethers.parseEther("21.0") })
ContractTransactionResponse {
  provider: HardhatEthersProvider {
    _hardhatProvider: LazyInitializationProviderAdapter {
      _providerFactory: [AsyncFunction (anonymous)],
      _emitter: [EventEmitter],
      _initializingPromise: [Promise],
      provider: [BackwardsCompatibilityProviderAdapter]
    },
    _networkName: 'localhost',
    _blockListeners: [],
    _transactionHashListeners: Map(0) {},
    _eventListeners: []
  },
  blockNumber: 3,
  blockHash: '0x9480f6754700591976529251601221565bea22da18a401b8c1f5d07162eb83bc',
  index: undefined,
  hash: '0x211f9034cfc89f241e2435c80491792fac238b42b1f810599b0fa0170ad0f096',
  type: 2,
  to: '0x5FbDB2315678afecb367f032d93F642f64180aa3',
  from: '0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266',
  nonce: 2,
  gasLimit: 30000000n,
  gasPrice: 854713878n,
  maxPriorityFeePerGas: 204961951n,
  maxFeePerGas: 854713878n,
  maxFeePerBlobGas: null,
  data: '0xfc541ef3000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000000000001',
  value: 21000000000000000000n,
  chainId: 31337n,
  signature: Signature { r: "0x82378e536cd1575bf6e8335625e2cc11083aadbb068f6d12b2bea6e3d6e91e1d", s: "0x308834197428226a2b6c182e2f55bbaa328aca88a02f276f425f17cf52c97bf1", yParity: 0, networkV: null },
  accessList: [],
  blobVersionedHashes: null
}
> const contractbal2 =  await ethers.provider.getBalance(cd.target)
undefined
> contractbal1
100000000000000000000n
> contractbal2
79000000000000000000n
> assert.equal((contractbal1 - ethers.parseEther("21.0")), (bal2 ), 'the amount will have increased by 21 ether')
Uncaught ReferenceError: bal2 is not defined
> assert.equal((contractbal1 - ethers.parseEther("21.0")), (contractbal2 ), 'the amount will have increased by 21 ether')
undefined
> assert.equal((contractbal1 + ethers.parseEther("21.0")), (contractbal2 ), 'the amount will have increased by 21 ether')
Uncaught AssertionError [ERR_ASSERTION]: the amount will have increased by 21 ether
    at REPL149:1:8
    at Script.runInThisContext (node:vm:122:12)
    at REPLServer.defaultEval (node:repl:594:29)
    at bound (node:domain:433:15)
    at REPLServer.runBound [as eval] (node:domain:444:12)
    at REPLServer.onLine (node:repl:924:10)
    at REPLServer.emit (node:events:529:35)
    at REPLServer.emit (node:domain:489:12)
    at REPLServer.[_onLine] [as _onLine] (node:internal/readline/interface:423:12)
    at REPLServer.[_line] [as _line] (node:internal/readline/interface:894:18) {
  generatedMessage: false,
  code: 'ERR_ASSERTION',
  actual: 121000000000000000000n,
  expected: 79000000000000000000n,
  operator: '=='
}
>

Compiled 1 Solidity file successfully (evm target: paris).
Welcome to Node.js v18.19.1.
Type ".help" for more information.
> const signers = await ethers.getSigners();
undefined
> const contract =  await ethers.getContractFactory("Gaming")
undefined
> const cd = await contract.deploy()
undefined
> const [deployer] = await ethers.getSigners();
undefined
            

Uncaught SyntaxError: missing ) after argument list
> cd.fundGame({value: ethers.parseEther("100.0")})
Promise {
  <pending>,
  [Symbol(async_id_symbol)]: 4726,
  [Symbol(trigger_async_id_symbol)]: 14
}
> await ethers.provider.getBalance(cd.target)
100000000000000000000n
> await ethers.provider.getBalance(signers[0])
9899999020535616744891n
>


> const val2 = await ethers.provider.getBalance(signers[0])

await cd.winOrLose(10, true, {from: signers[0] ,value: ethers.parseEther("21.0") })

> val1
9896998827779994338625n
> val2
9875998814539927327409n
>


> const bal1 = await ethers.provider.getBalance(cd2.target)
> await cd2.winOrLose(10, true, {from: signers[0] ,value: ethers.parseEther("21.0") })

> const bal2 = await ethers.provider.getBalance(cd2.target)
> await cd2.winOrLose(10, true, {from: signers[0] ,value: ethers.parseEther("21.0") })

 assert.equal((bal1 + ethers.parseEther("21.0")), (bal2 ), 'the amount will have increased by 21 ether')
